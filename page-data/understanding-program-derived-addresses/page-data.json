{"componentChunkName":"component---src-templates-blog-post-js","path":"/understanding-program-derived-addresses/","result":{"data":{"site":{"siteMetadata":{"title":"Brian Friel","author":"Brian Friel"}},"markdownRemark":{"id":"80311ffe-d657-51c8-9050-dec078dc65b2","excerpt":"This is a follow up to my previous post Learning How to Build on Solana. Check out the live app and its updated code. Picking Up Where We Left Off In my last…","html":"<p><em>This is a follow up to my previous post <a href=\"https://brianfriel.xyz/learning-how-to-build-on-solana/\">Learning How to Build on Solana</a>.</em></p>\n<blockquote>\n<p>Check out the <a href=\"https://www.pbvote.com/\">live app</a> and its <a href=\"https://github.com/bfriel/crunchy-vs-smooth-v2\">updated code</a>.</p>\n</blockquote>\n<h2>Picking Up Where We Left Off</h2>\n<p>In my <a href=\"https://www.brianfriel.xyz/learning-how-to-build-on-solana/\">last post</a>, we built a simple <a href=\"https://www.pbvote.com/\">app</a> that let <a href=\"https://solana.com/\">Solana</a> users vote for their favorite type of peanut butter: Crunchy or Smooth?</p>\n<p>Working with <a href=\"https://project-serum.github.io/anchor/getting-started/introduction.html\">Anchor</a> made our lives a lot easier. In less than 50 lines of <a href=\"https://www.rust-lang.org/\">Rust</a>, we could write our own program and have confidence that it would meet the demanding serialization and deserialization requirements set forth by its <a href=\"https://docs.solana.com/developing/on-chain-programs/overview#input-parameter-serialization\">BPF Loader</a>.</p>\n<p>We deployed our program and spun up a frontend to interact with it, but something was missing. Our app worked, but the <a href=\"https://docs.solana.com/terminology#keypair\">keypair</a> that held all our data was stored on some <a href=\"https://nodejs.org/en/\">Node</a> server maintained by <a href=\"https://www.heroku.com/\">Heroku</a>. This didn’t feel very web3. Furthermore, it created a lot of headaches around storing and securing our keypair. Anytime our server restarted, we’d generate a new keypair thus reset all our data.</p>\n<p>How do production apps get around this issue? Instead of storing a keypair somewhere, most apps use something called a <a href=\"https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses\">Program Derived Address (PDA)</a>. To understand how PDAs work, let’s first take a step back and get a quick refresher on how Solana programs read and write data.</p>\n<h2>How Solana Stores Data</h2>\n<p>As you may recall, Solana completely separates code from data. In Solana, all programs are stateless: any data that they work with must be passed in by reference from the outside.</p>\n<p>In the case of our app, this means there is no way for our voting program to internally update its own vote count for crunchy or smooth. So where do these votes live? The answer is something called an <a href=\"https://docs.solana.com/developing/programming-model/accounts\">account</a>.</p>\n<h3>Accounts</h3>\n<p>Accounts can be thought of as collections of related information, similar to a file in an operating system. Accounts are both used by and owned by programs, and a single program can own many different accounts.</p>\n<p>If you’re familiar with <a href=\"https://ethereum.org/en/developers/docs/accounts/\">Ethereum</a>, this terminology may confuse you. To quote <a href=\"https://2501babe.github.io/posts/solana101.html\">hana</a>:</p>\n<blockquote>\n<p>accounts are buffers. i dont know why they call them accounts it confuses the shit out of everyone.</p>\n</blockquote>\n<p>Like a file, accounts can store arbitrary kinds of data (e.g. integers, strings, pubkeys) as well as SOL. Accounts also have metadata which describes who is allowed to access its data and <a href=\"https://docs.solana.com/developing/programming-model/accounts#rent\">how long the account can live for</a>. Anyone can read or credit an account, but only the account owner can debit it or modify its data.</p>\n<p>Accounts are created by simply generating a new keypair and registering its public key with the <a href=\"https://docs.solana.com/developing/programming-model/accounts#creating\">System Program</a>. Each account is identified by its unique address (aka public key), the same kind which is used to identify your <a href=\"https://phantom.app/\">Phantom</a> wallet. In our case, we can lookup our vote account at <a href=\"https://explorer.solana.com/address/9pKBrUtJU9GNmct6T2BQtiKqvubtjS9D2if2bm1P8TQd\"><code class=\"language-text\">9pKBrUtJU9GNmct6T2BQtiKqvubtjS9D2if2bm1P8TQd</code></a>. This begs the question: if our vote account can be looked up with what looks like a public key, who holds the private key for this account? The answer is nobody! How then is our program able to record votes as they occur? Enter: PDAs.</p>\n<h3>Program Derived Addresses (PDAs)</h3>\n<p>A Program Derived Address (PDA) is home to an account that’s designed to be controlled by a specific program. With PDAs, programs can programatically sign for certain addresses without needing a private key. At the same time, PDAs ensure that no external user could also generate a valid signature for the same address. These addresses serve as the foundation for <a href=\"https://docs.solana.com/developing/programming-model/calling-between-programs\">Cross-Program Invocation</a>, which allows Solana apps to be composable with one another.</p>\n<p>The secret sauce behind PDAs is that while they look like standard public keys, they don’t actually lie on the ed25519 elliptic curve at all. This means they have no associated private key. You might be asking yourself, “How can a program sign for an account that has no private key?” The answer lies in how PDAs are derived.</p>\n<h4>Seeds and Bumps</h4>\n<p>PDAs are derived from a program id (in our case, <a href=\"https://explorer.solana.com/address/6a2GdmttJdanBkoHt7f4Kon4hfadx4UTUgJeRkCaiL3U\"><code class=\"language-text\">6a2GdmttJdanBkoHt7f4Kon4hfadx4UTUgJeRkCaiL3U</code></a>) and a collection of seeds such as the string <code class=\"language-text\">\"vote_account\"</code>. This combination of seeds and a program id is then run through a sha256 hash function to see whether or not they generate a public key that lies on the elliptic curve.</p>\n<p>It may be helpful to consider that PDAs are not technically <em>created</em>, but rather <em>found</em>. In running our program id and seeds through a hash function, there is a ~50% chance that we actually end up with a valid public key that does lie on the elliptic curve. In this case, we simply add something to fudge our input a little bit and try again. The technical term for this fudge factor is a <code class=\"language-text\">bump</code>. In Solana, we start with <code class=\"language-text\">bump = 255</code> and simply iterate down through <code class=\"language-text\">bump = 254</code>, <code class=\"language-text\">bump = 253</code>, etc. until we get an address that is not on the elliptic curve. This may seem rudimentary, but once found it gives us a deterministic way of deriving the same PDA over and over again. This also allows our program to now sign for an account using <a href=\"https://docs.solana.com/developing/programming-model/calling-between-programs#program-signed-accounts\">Solana’s <code class=\"language-text\">invoke_signed</code> function</a>.</p>\n<p>It’s important to note that our seed does not have to be static. In fact, a common practice is to generate PDAs using the public key of an end user, allowing our program to store information about that user in its own standalone account.</p>\n<h2>Refactoring Our Program</h2>\n<p>Armed with this knowledge, we can now go about refactoring <a href=\"https://github.com/bfriel/crunchy-vs-smooth\">our original Anchor program</a> to make use of PDAs. We’ll retain the same structure of having an <code class=\"language-text\">Initialize</code> instruction and a <code class=\"language-text\">Vote</code> instruction, but modify them to record votes on a PDA owned by our program rather than a standard account generated by a keypair.</p>\n<p>Starting off with the <code class=\"language-text\">initialize</code> method, we’ll now pass in a second parameter <code class=\"language-text\">vote_account_bump</code> and record that on the account itself. This will make it easy for Anchor to handle all future account validations. Check out the diff between our first version and this updated version below:</p>\n<deckgo-highlight-code language=\"diff\"  >\n          <code slot=\"code\">-    pub fn initialize(ctx: Context&lt;Initialize&gt;) -&gt; ProgramResult {\n-        let vote_account = &amp;mut ctx.accounts.vote_account;\n-       vote_account.crunchy = 0;\n-        vote_account.smooth = 0;\n-        Ok(())\n-    }\n+    pub fn initialize(ctx: Context&lt;Initialize&gt;, vote_account_bump: u8) -&gt; ProgramResult {\n+        ctx.accounts.vote_account.bump = vote_account_bump;\n+        Ok(())\n+    }</code>\n        </deckgo-highlight-code>\n<p>You’ll notice that we’re also no longer manually setting both <code class=\"language-text\">crunchy = 0</code> and <code class=\"language-text\">smooth = 0</code>. We can skip this by using Rust’s <a href=\"https://doc.rust-lang.org/std/default/trait.Default.html\"><code class=\"language-text\">#[derive(Default)]</code> macro</a> on the struct that defines what our <code class=\"language-text\">vote_account</code> looks like. If you’re following along from my last example, I renamed this struct from <code class=\"language-text\">VoteAccount</code> to <code class=\"language-text\">VotingState</code>.</p>\n<deckgo-highlight-code language=\"rust\"  >\n          <code slot=\"code\">#[account]\n#[derive(Default)]\npub struct VotingState {\n    crunchy: u64,\n    smooth: u64,\n    bump: u8,\n}</code>\n        </deckgo-highlight-code>\n<p>We’ll also update our <code class=\"language-text\">Initialize</code> instruction to make use of our PDA. Here, we’re deriving a PDA from the static seed <code class=\"language-text\">\"vote_account\"</code> and the <code class=\"language-text\">vote_account_bump</code> passed in by whoever first calls <code class=\"language-text\">initialize</code>. I’ve added comments that explain what each line is doing below.</p>\n<deckgo-highlight-code language=\"rust\"  >\n          <code slot=\"code\">#[derive(Accounts)]\n#[instruction(vote_account_bump: u8)]\npub struct Initialize&lt;&#39;info&gt; {\n\n    /// The #[account(...)] macro enforces that our `vote_account` is owned by the currently executing program.\n    ///\n    /// We mark `vote_account` with the `init` attribute, which creates a new account owned by the program\n    /// When using `init`, we must also provide:\n    /// `payer`, which funds the account creation\n    /// and the `system_program` which is required by the runtime\n    ///\n    /// If our account were to use variable length types like String or Vec we would also need to allocate `space` to our account\n    /// Since we are only dealing with fixed-sized integers, we can leave out `space` and Anchor will calculate this for us automatically\n    ///\n    /// `seeds` and `bump` tell us that our `vote_account` is a PDA that can be derived from their respective values\n    /// Account&lt;&#39;info, VotingState&gt; tells us that it should be deserialized to the VotingState struct defined below at #[account]\n    #[account(init, seeds = [b&quot;vote_account&quot;.as_ref()], bump = vote_account_bump, payer = user)]\n    vote_account: Account&lt;&#39;info, VotingState&gt;,\n    user: Signer&lt;&#39;info&gt;,\n    system_program: Program&lt;&#39;info, System&gt;,\n}</code>\n        </deckgo-highlight-code>\n<p>We’ll then repeat a similar pattern for our <code class=\"language-text\">Vote</code> instruction and its two methods, <code class=\"language-text\">vote_crunchy</code> and <code class=\"language-text\">vote_smooth</code>. I’ve pasted my entire program below, complete with comments. Take note of how we can now access <code class=\"language-text\">bump = vote_account.bump</code> thanks to our new <code class=\"language-text\">initialize</code> method.</p>\n<deckgo-highlight-code language=\"rust\"  >\n          <code slot=\"code\">use anchor_lang::prelude::*;\n\ndeclare_id!(&quot;6a2GdmttJdanBkoHt7f4Kon4hfadx4UTUgJeRkCaiL3U&quot;);\n/// The Program ID can be found in /target/idl/[your_project_name].json\n//\n/// This is where the magic happens. We define our program!\n/// Each method inside here defines an RPC request handler (aka instruction handler) which can be invoked by clients\n#[program]\nmod crunchy_vs_smooth {\n    use super::*;\n\n    /// The first parameter for every RPC handler is the Context struct. We define Initialize and Vote below at #[derive(Accounts)]\n    /// When `initialize` is called, we&#39;ll store the `vote_account_bump` that was used to derive our PDA so that others can easily derive it on their clients\n    /// We no longer have to manually set both `crunchy` and `smooth` to 0 because we opted to use the `default` trait on our VotingState struct at the bottom of this file\n    /// This a Rust trait that is used via #[derive(Default)]. More info on that here: https://doc.rust-lang.org/std/default/trait.Default.html\n    pub fn initialize(ctx: Context&lt;Initialize&gt;, vote_account_bump: u8) -&gt; ProgramResult {\n        ctx.accounts.vote_account.bump = vote_account_bump;\n        Ok(())\n    }\n\n    /// All our account validation logic is handled below at the #[account(...)] macros, letting us just focus our business logic\n    pub fn vote_crunchy(ctx: Context&lt;Vote&gt;) -&gt; ProgramResult {\n        ctx.accounts.vote_account.crunchy += 1;\n        Ok(())\n    }\n\n    pub fn vote_smooth(ctx: Context&lt;Vote&gt;) -&gt; ProgramResult {\n        ctx.accounts.vote_account.smooth += 1;\n        Ok(())\n    }\n}\n\n/// The #[derive(Accounts)] macro specifies all the accounts that are required for a given instruction\n/// Here, we define two structs: Initialize and Vote\n#[derive(Accounts)]\n#[instruction(vote_account_bump: u8)]\npub struct Initialize&lt;&#39;info&gt; {\n\n    /// The #[account(...)] macro enforces that our `vote_account` is owned by the currently executing program.\n    ///\n    /// We mark `vote_account` with the `init` attribute, which creates a new account owned by the program\n    /// When using `init`, we must also provide:\n    /// `payer`, which funds the account creation\n    /// and the `system_program` which is required by the runtime\n    ///\n    /// If our account were to use variable length types like String or Vec we would also need to allocate `space` to our account\n    /// Since we are only dealing with fixed-sized integers, we can leave out `space` and Anchor will calculate this for us automatically\n    ///\n    /// `seeds` and `bump` tell us that our `vote_account` is a PDA that can be derived from their respective values\n    /// Account&lt;&#39;info, VotingState&gt; tells us that it should be deserialized to the VotingState struct defined below at #[account]\n    #[account(init, seeds = [b&quot;vote_account&quot;.as_ref()], bump = vote_account_bump, payer = user)]\n    vote_account: Account&lt;&#39;info, VotingState&gt;,\n    user: Signer&lt;&#39;info&gt;,\n    system_program: Program&lt;&#39;info, System&gt;,\n}\n\n#[derive(Accounts)]\npub struct Vote&lt;&#39;info&gt; {\n    #[account(mut, seeds = [b&quot;vote_account&quot;.as_ref()], bump = vote_account.bump)]\n    vote_account: Account&lt;&#39;info, VotingState&gt;,\n}\n\n/// Here we define what what the state of our `vote_account` looks like\n/// We define a struct with three public properties: crunchy, smooth, and bump\n/// The `crunchy` and `smooth` properties will keep track of their respective votes as unsigned 64-bit integers\n/// `bump` will store the `vote_account_bump` we passed in when we initialized our program\n/// This `bump` combined with our static &quot;vote_account&quot; seed will make it easy for anyone to derive the same PDA we use use to keep track of our state\n/// All of this will be passed inside each Transaction Instruction to record votes as they occur\n#[account]\n#[derive(Default)]\npub struct VotingState {\n    crunchy: u64,\n    smooth: u64,\n    bump: u8,\n}</code>\n        </deckgo-highlight-code>\n<h4>Updating our Frontend</h4>\n<p>With our program now making use of a PDA, it’s time to hook up our frontend. If you’re following along in your own repo, make sure to follow the necessary steps involved with rebuilding and deploying your program locally. I outlined the steps I use my <a href=\"https://www.brianfriel.xyz/learning-how-to-build-on-solana/\">last post</a>, which are:</p>\n<ol>\n<li>Set your Solana configuration</li>\n</ol>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\"># replace devnet with your desired network (i.e. localhost, testnet, mainnet-beta)\nsolana config set --url devnet</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>Copy this network to your <code class=\"language-text\">Anchor.toml</code> file</li>\n<li>Rebuild your Anchor program and make sure your program ID matches what’s in <code class=\"language-text\">Anchor.toml</code> (it usually does)</li>\n</ol>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">anchor build</code>\n        </deckgo-highlight-code>\n<ol start=\"4\">\n<li>Deploy your program</li>\n</ol>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">anchor deploy</code>\n        </deckgo-highlight-code>\n<ol start=\"5\">\n<li>In our frontend directory, update the network url to your desired network (i.e. <code class=\"language-text\">clusterApiUrl(\"devnet\")</code>)</li>\n<li>Update network settings in your Phantom wallet</li>\n</ol>\n<p>I won’t be going through every update to my React app, but you are welcome to copy the entire directory from <a href=\"https://github.com/bfriel/crunchy-vs-smooth-v2/tree/master/app\">my Github</a>. I will however go over a few PDA-specific updates that should drive home how one can work with these addresses.</p>\n<p>The biggest update is to our <code class=\"language-text\">getVoteAccount()</code> function. In our previous app, we stored the keypair to our account on our Node server and requested this keypair anytime we needed it (bad!). Now, we’re deriving a PDA ourselves from our <code class=\"language-text\">\"vote_account\"</code> seed, our <code class=\"language-text\">programID</code>, and an <code class=\"language-text\">accountBump</code>. To find this bump, we’ll use <a href=\"https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#findProgramAddress\">Solana web3js’s <code class=\"language-text\">findProgramAddress</code></a> to iterate through all possibilities.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// In src/App.js\n\nuseEffect(() =&gt; {\n  const getVoteAccount = async () =&gt; {\n    let account,\n      accountBump = null\n    ;[account, accountBump] = await web3.PublicKey.findProgramAddress(\n      [Buffer.from(&quot;vote_account&quot;)],\n      programID\n    )\n    setVoteAccount({ account, accountBump })\n  }\n  getVoteAccount()\n}, [])</code>\n        </deckgo-highlight-code>\n<p>Once we find a <code class=\"language-text\">voteAccountBump</code> that kicks us off the elliptic curve, we can then pass it as an argument to the <code class=\"language-text\">initialize</code> method we created earlier.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// In src/components/Main.jsx\n\nasync function initializeVoting() {\n  const provider = await getProvider()\n  const program = new Program(idl, programID, provider)\n  try {\n    await program.rpc.initialize(new BN(voteAccountBump), {\n      accounts: {\n        user: provider.wallet.publicKey,\n        voteAccount: voteAccount,\n        systemProgram: web3.SystemProgram.programId,\n      },\n    })\n    const account = await program.account.votingState.fetch(voteAccount)\n    setVotes({\n      crunchy: account.crunchy?.toNumber(),\n      smooth: account.smooth?.toNumber(),\n    })\n    enqueueSnackbar(&quot;Vote account initialized&quot;, { variant: &quot;success&quot; })\n  } catch (error) {\n    console.log(&quot;Transaction error: &quot;, error)\n    console.log(error.toString())\n    enqueueSnackbar(`Error: ${error.toString()}`, { variant: &quot;error&quot; })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>Once <code class=\"language-text\">initialize</code> is called, we’ll be all set up with a PDA to handle our crunchy and smooth voting needs. The rest of our frontend should be straightforward if you’ve read through my <a href=\"https://www.brianfriel.xyz/learning-how-to-build-on-solana/\">previous walkthrough</a>.</p>\n<h3>Wrapping Up</h3>\n<p>If you’re new to Solana, I hope this walkthrough helped shed a little light on what PDAs are and how you can go about implementing them in your own projects. If you have questions or feedback on this post, please reach out to me via <a href=\"https://twitter.com/bfriel_\">Twitter</a>. Special thanks to everyone in the Anchor discord who helped me gain a better understanding of PDAs, especially <a href=\"https://twitter.com/cqfdee\">@cqfd (Alan)</a> and @donderper.</p>","timeToRead":12,"frontmatter":{"title":"Understanding Program Derived Addresses","date":"October 21, 2021","description":"A practical overview of how Solana programs read and write data.","featuredImage":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAYABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB86iTrFWIUuaUcwn/xAAZEAACAwEAAAAAAAAAAAAAAAAAEQIQEiL/2gAIAQEAAQUCFmWah1LSGxV//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPwFG3//EABcRAQADAAAAAAAAAAAAAAAAAAEAEBH/2gAIAQIBAT8BZjf/xAAYEAADAQEAAAAAAAAAAAAAAAAAASEQIP/aAAgBAQAGPwISm0j4/8QAGhAAAwEBAQEAAAAAAAAAAAAAAAERMSFRof/aAAgBAQABPyGLmEMFDRL6PBprxCnabKXrCJZ9Gf/aAAwDAQACAAMAAAAQRDc+/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQESH/2gAIAQMBAT8QYoLY/8QAFxEAAwEAAAAAAAAAAAAAAAAAARAhMf/aAAgBAgEBPxAFGYv/xAAcEAEBAQEBAAMBAAAAAAAAAAABESEAMUFRYeH/2gAIAQEAAT8QEbofZzpQVvnRgBH641QS4b89i0WG+v8Aej5pAeECSMkzqobC4uTWYfnf/9k=","aspectRatio":0.8438818565400844,"src":"/static/3cdcb5b683ec3ccd408e5e14799c69a4/54796/monkeys.jpg","srcSet":"/static/3cdcb5b683ec3ccd408e5e14799c69a4/f836f/monkeys.jpg 200w,\n/static/3cdcb5b683ec3ccd408e5e14799c69a4/2244e/monkeys.jpg 400w,\n/static/3cdcb5b683ec3ccd408e5e14799c69a4/54796/monkeys.jpg 481w","sizes":"(max-width: 481px) 100vw, 481px"},"resize":{"src":"/static/3cdcb5b683ec3ccd408e5e14799c69a4/8275e/monkeys.jpg"}}},"thumbnail":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAYABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB86iTrFWIUuaUcwn/xAAZEAACAwEAAAAAAAAAAAAAAAAAEQIQEiL/2gAIAQEAAQUCFmWah1LSGxV//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPwFG3//EABcRAQADAAAAAAAAAAAAAAAAAAEAEBH/2gAIAQIBAT8BZjf/xAAYEAADAQEAAAAAAAAAAAAAAAAAASEQIP/aAAgBAQAGPwISm0j4/8QAGhAAAwEBAQEAAAAAAAAAAAAAAAERMSFRof/aAAgBAQABPyGLmEMFDRL6PBprxCnabKXrCJZ9Gf/aAAwDAQACAAMAAAAQRDc+/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQESH/2gAIAQMBAT8QYoLY/8QAFxEAAwEAAAAAAAAAAAAAAAAAARAhMf/aAAgBAgEBPxAFGYv/xAAcEAEBAQEBAAMBAAAAAAAAAAABESEAMUFRYeH/2gAIAQEAAT8QEbofZzpQVvnRgBH641QS4b89i0WG+v8Aej5pAeECSMkzqobC4uTWYfnf/9k=","aspectRatio":0.8426966292134831,"src":"/static/3cdcb5b683ec3ccd408e5e14799c69a4/54796/monkeys.jpg","srcSet":"/static/3cdcb5b683ec3ccd408e5e14799c69a4/aabdf/monkeys.jpg 150w,\n/static/3cdcb5b683ec3ccd408e5e14799c69a4/9dc27/monkeys.jpg 300w,\n/static/3cdcb5b683ec3ccd408e5e14799c69a4/54796/monkeys.jpg 481w","sizes":"(max-width: 481px) 100vw, 481px"}}}}}},"pageContext":{"slug":"/understanding-program-derived-addresses/","previous":{"fields":{"slug":"/learning-how-to-build-on-solana/"},"frontmatter":{"title":"Learning How to Build on Solana"}},"next":{"fields":{"slug":"/how-to-create-a-token-on-solana/"},"frontmatter":{"title":"Creating Tokens on Solana"}}}},"staticQueryHashes":["1347968780","702208682"]}